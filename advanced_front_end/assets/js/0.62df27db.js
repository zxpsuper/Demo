(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{156:function(t,r,a){"use strict";a.r(r);var s=a(0),e=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,r=t.$createElement,a=t._self._c||r;return a("div",{staticClass:"content"},[a("h3",{attrs:{id:"vue-router-原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-router-原理","aria-hidden":"true"}},[t._v("#")]),t._v(" Vue-router 原理")]),a("h4",{attrs:{id:"hash模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hash模式","aria-hidden":"true"}},[t._v("#")]),t._v(" Hash模式")]),a("p",[t._v("vue-router默认使用Hash模式.")]),a("p",[t._v("使用url的hash来模拟一个完整的url.此时url变化时,浏览器是不会重新加载的.")]),a("blockquote",[a("p",[t._v("Hash(即#)是url的锚点,代表的是网页中的一个位置,仅仅改变#后面部分,浏览器只会滚动对应的位置,而不会重新加载页面.#仅仅只是对浏览器进行指导,而对服务端是完全没有作用的!它不会被包括在http请求中,故也不会重新加载页面.同时hash发生变化时,url都会被浏览器记录下来,这样你就可以使用浏览器的后退了.\n总而言之:Hash模式就是通过改变#后面的值,实现浏览器渲染指定的组件.")])]),a("h4",{attrs:{id:"history模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#history模式","aria-hidden":"true"}},[t._v("#")]),t._v(" History模式")]),a("p",[t._v("如果你不喜欢hash这种#样式.可以使用history模式.这种模式利用了HTML5 History新增的pushState()和replaceState()方法. 除了之前的back,forward,go方法,这两个新方法可以应用在浏览器历史记录的增加替换功能上.使用History模式,通过历史记录修改url,但它不会立即向后端发送请求.")]),a("p",[t._v('注意点: 虽然History模式可以丢掉不美观的#,也可以正常的前进后退,但是刷新f5后,此时浏览器就会访问服务器,在没有后台支持的情况下,此时就会得到一个404!官方文档给出的描述是:"不过这种模式要玩好,还需要后台配置支持.因为我们的应用是单个客户端应用,如果后台没有正确的配置,当用户直接访问时,就会返回404.所以呢,你要在服务端增加一个覆盖所有情况的的候选资源;如果url匹配不到任何静态资源,则应该返回同一个index.html页面."\n总而言之:History模式就是通过pushState()方法来对浏览器的浏览记录进行修改,来达到不用请求后端来渲染的效果.不过建议,实际项目还是使用history模式.')])])}],!1,null,null,null);r.default=e.exports}}]);